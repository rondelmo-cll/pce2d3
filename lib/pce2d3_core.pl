:- use_module(pce2d3_config).

% http://www.swi-prolog.org/pldoc/man?section=reexport
%% this program can be switched.
%%   if you switch output_to_pce on,  uncomment the following reexport lines.
%%   if you switch output_to_pce off,   comment the following reexport lines.

:- reexport(library(pce),
			except([
			  new/2 as origpce_new,
			  free/1 as origpce_free,
			  send/2 as origpce_send,
			  send/3 as origpce_send,
			  send/4 as origpce_send,
			  send/5 as origpce_send,
			  send/6 as origpce_send,
			  send/7 as origpce_send,
			  send/8 as origpce_send,
			  get/3 as origpce_get,
			  get/4 as origpce_get,
			  get/5 as origpce_get,
			  get/6 as origpce_get,
			  get/7 as origpce_get,
			  get/8 as origpce_get
					  ])).

:- multifile     d3intercept/2, d3intercept/3, d3intercept/4, d3intercept/5, d3intercept/6, d3intercept/7, d3intercept/8, d3intercept/9.
:- discontiguous d3intercept/2, d3intercept/3, d3intercept/4, d3intercept/5, d3intercept/6, d3intercept/7, d3intercept/8, d3intercept/9.

% 
% NEW
% 

% 
% new(A,B) :-
% 	(output_to_d3, d3intercept(new,A,B), writef("new: A is %w",[A]), fail) ;
% 	(output_to_pce, origpce_new(A,B)) ; true.
% 
% 

new(A,B) :- output_to_d3, d3intercept(new,A,B).
new(A,B) :- output_to_pce, origpce_new(A,B).


% 
% FREE
% 

free(A) :- output_to_d3, d3intercept(free,A).
free(A) :- output_to_pce, origpce_free(A).


%
% SEND
%
send(A) :- output_to_d3, d3intercept(send,A).
send(A) :- output_to_pce, origpce_send(A).
send(A,B) :- output_to_d3, d3intercept(send,A,B).
send(A,B) :- output_to_pce, origpce_send(A,B).
send(A,B,C) :- output_to_d3, d3intercept(send,A,B,C).
send(A,B,C) :- output_to_pce, origpce_send(A,B,C).
send(A,B,C,D) :- output_to_d3, d3intercept(send,A,B,C,D).
send(A,B,C,D) :- output_to_pce, origpce_send(A,B,C,D).
send(A,B,C,D,E) :- output_to_d3, d3intercept(send,A,B,C,D,E).
send(A,B,C,D,E) :- output_to_pce, origpce_send(A,B,C,D,E).
send(A,B,C,D,E,F) :- output_to_d3, d3intercept(send,A,B,C,D,E,F).
send(A,B,C,D,E,F) :- output_to_pce, origpce_send(A,B,C,D,E,F).
send(A,B,C,D,E,F,G) :- output_to_d3, d3intercept(send,A,B,C,D,E,F,G).
send(A,B,C,D,E,F,G) :- output_to_pce, origpce_send(A,B,C,D,E,F,G).
send(A,B,C,D,E,F,G,H) :- output_to_d3, d3intercept(send,A,B,C,D,E,F,G,H).
send(A,B,C,D,E,F,G,H) :- output_to_pce, origpce_send(A,B,C,D,E,F,G,H).




%
% GET
%
% we might need a way to call d3 getters to satisfy the callers
get(A) :- output_to_d3, d3intercept(get,A).
get(A) :- output_to_pce, origpce_get(A).
get(A,B) :- output_to_d3, d3intercept(get,A,B).
get(A,B) :- output_to_pce, origpce_get(A,B).
get(A,B,C) :- output_to_d3, d3intercept(get,A,B,C).
get(A,B,C) :- output_to_pce, origpce_get(A,B,C).
get(A,B,C,D) :- output_to_d3, d3intercept(get,A,B,C,D).
get(A,B,C,D) :- output_to_pce, origpce_get(A,B,C,D).
get(A,B,C,D,E) :- output_to_d3, d3intercept(get,A,B,C,D,E).
get(A,B,C,D,E) :- output_to_pce, origpce_get(A,B,C,D,E).
get(A,B,C,D,E,F) :- output_to_d3, d3intercept(get,A,B,C,D,E,F).
get(A,B,C,D,E,F) :- output_to_pce, origpce_get(A,B,C,D,E,F).
get(A,B,C,D,E,F,G) :- output_to_d3, d3intercept(A,B,C,D,E,F,G).
get(A,B,C,D,E,F,G) :- output_to_pce, origpce_get(A,B,C,D,E,F,G).
get(A,B,C,D,E,F,G,H) :- output_to_d3, d3intercept(get,A,B,C,D,E,F,G,H).
get(A,B,C,D,E,F,G,H) :- output_to_pce, origpce_get(A,B,C,D,E,F,G,H).



% 
% setupd3 -- a helper function to set up the symbol table.
% 

setupd3 :-
	output_to_d3, writef("
// the following code was autogenerated from xpce source by pce2d3.pl
var pg = d3.select(\"#pcegroup\") || d3.select(\"body\").append(\"div\").attr(\"id\",\"pcegroup\");
var symbols = {};
",[]).



%
% default d3intercepts
%
% these are catch-all functions; if you get JS output looking like the below, then you probably need to write more "transpiler" code in the section about.
%
d3intercept(AA,A) :- writef("// d3intercept %w,%w\n",[AA,A]).
d3intercept(AA,A,B) :- writef("// d3intercept %w,%w,%w\n",[AA,A,B]).
d3intercept(AA,A,B,C) :- writef("// d3intercept %w,%w,%w,%w\n",[AA,A,B,C]).
d3intercept(AA,A,B,C,D) :- writef("// d3intercept %w,%w,%w,%w,%w\n",[AA,A,B,C,D]).
d3intercept(AA,A,B,C,D,E) :- writef("// d3intercept %w,%w,%w,%w,%w,%w\n",[AA,A,B,C,D,E]).
d3intercept(AA,A,B,C,D,E,F) :- writef("// d3intercept %w,%w,%w,%w,%w,%w,%w\n",[AA,A,B,C,D,E,F]).
d3intercept(AA,A,B,C,D,E,F,G) :- writef("// d3intercept %w,%w,%w,%w,%w,%w,%w,%w\n",[AA,A,B,C,D,E,F,G]).
d3intercept(AA,A,B,C,D,E,F,G,H) :- writef("// d3intercept %w,%w,%w,%w,%w,%w,%w,%w,%w\n",[AA,A,B,C,D,E,F,G,H]).


% helper function -- strip @ from object name to make it a legal js variable name
% at_less(@foo,X)
% if it is a free variable, unify it with an incremented global ID. this is not thread-safe.
% note that unification does not survive upstream parental backtracking,
% so avoid syntax like ( do_d3 -> ...,  fail ); (do_pce -> ..., true )
at_less(T,OutT) :-
	( var(T) -> (next_id(N), concat("d3_",N,T)) ; true ),
	term_string(T,S),
	(   sub_string(S,0,1,_,"@")
	 -> sub_string(S,1,_,0,Out )
	 ;  Out = S),
	term_string(OutT,Out).

next_id(Id) :-
    flag(my_id, Id, Id+1).
